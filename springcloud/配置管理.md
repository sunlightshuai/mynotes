# Spring Cloud Config
Spring Cloud Config为分布式系统中的外部化配置提供服务器端和客户端支持。使用Config Server，可以在所有环境中管理应用程序的外部属性。客户端和服务器上的概念映射与Spring Environment和PropertySource抽象，因此它们非常适合Spring应用程序，但可以与任何语言运行的任何应用程序一起使用。当应用程序通过部署管道从开发到测试再到生产时，您可以管理这些环境之间的配置，并确保应用程序具有迁移时需要运行的所有内容。服务器存储后端的默认实现使用git，因此它可以轻松支持配置环境的标签版本，以及可用于管理内容的各种工具。添加替代实现并使用Spring配置插入它们很容易。

## 使用

### pom引用

```xml

	<dependencies> 
		<dependency> 
			<groupId> org.springframework.cloud </ groupId> 
			<artifactId> spring-cloud-starter-config </ artifactId> 
		</ dependency> 
		<dependency> 
			<groupId> org.springframework.boot </ groupId > 
			<artifactId> spring-boot-starter-test </ artifactId> 
			<scope> test </ scope> 
		</ dependency> 
	</ dependencies>

```

### 自定义的使用

```java

	@SpringBootApplication
	@EnableConfigServer
	public class App {
    	public static void main( String[] args )  {
       		SpringApplication.run(App.class,args);
    	}
	}

```
## Spring Cloud Config Server

### Spring Environment
Environment 实现类 ConfigurableEnvironment:
ConfigurableEnvironment 中属性类 MutablePropertySources 
获取可变多个配置源 MutablePropertySources -> List PropertySource : 包含多个 PropertySource
PropertySource : 配置源
MapPropertySource
PropertiesPropertySource
CompositePropertySource : 组合
SystemEnvironmentPropertySource 环境变量
Spring Cloud 客户端配置定位扩展 : PropertySourceLocator

#### 分类
##### Git Backend
##### 版本控制文件
##### 文件系统
##### Vault后端
##### 通过代理访问
##### 与所有应用程序共享配置
##### JDBC后端
##### CredHub后端

## EnableConfigServer
```java

 	@Target({ElementType.TYPE})
	@Retention(RetentionPolicy.RUNTIME)
	@Documented
	@Import({ConfigServerConfiguration.class})
	public @interface EnableConfigServer {
	}

```
## ConfigServerConfiguration

```java

	@Configuration
	public class ConfigServerConfiguration {
    	public ConfigServerConfiguration() {
   	 	}

    	@Bean
		public ConfigServerConfiguration.Marker enableConfigServerMarker() {
        	return new ConfigServerConfiguration.Marker();
    	}

    	class Marker {
        	Marker() {
        	}
    	}
	}
```
## ConfigServerAutoConfiguration

```java

	@Configuration
	@ConditionalOnBean({Marker.class})
	@EnableConfigurationProperties({ConfigServerProperties.class})
	@Import({EnvironmentRepositoryConfiguration.class, CompositeConfiguration.class, ResourceRepositoryConfiguration.class, ConfigServerEncryptionConfiguration.class, ConfigServerMvcConfiguration.class})
	public class ConfigServerAutoConfiguration {
    	public ConfigServerAutoConfiguration() {
    	}
	}

```
## JDBC配置

* JdbcTemplate Bean 来源

  * `JdbcTemplateAutoConfiguration`

`EnvironmentRepository` 核心接口

```java

	@Configuration
	@ConditionalOnMissingBean(value = EnvironmentRepository.class, search = SearchStrategy.CURRENT)
	class DefaultRepositoryConfiguration {
	...
		@Bean
		public MultipleJGitEnvironmentRepository defaultEnvironmentRepository(
	        MultipleJGitEnvironmentRepositoryFactory gitEnvironmentRepositoryFactory,
			MultipleJGitEnvironmentProperties environmentProperties) throws Exception {
		return gitEnvironmentRepositoryFactory.build(environmentProperties);
	}
}
```

当 Spring 应用上下文没有出现 `EnvironmentRepository` Bean 的时候，那么，默认激活 `DefaultRepositoryConfiguration` (Git 实现)，否则采用自定义实现。

自定义 `EnvironmentRepository` Bean

```java

    @Bean
    public EnvironmentRepository environmentRepository() {
        return (String application, String profile, String label) -> {
            Environment environment = new Environment("default", profile);
            List<PropertySource> propertySources = environment.getPropertySources();
            Map<String, Object> source = new HashMap<>();
            source.put("name", "test");
            PropertySource propertySource = new PropertySource("map", source);
            // 追加 PropertySource
            propertySources.add(propertySource);
            return environment;
        };
    }

```