#主要内容

##RestTemplate原理与扩展

### `HttpMessageConvert`分析


```

	public interface HttpMessageConverter<T> {

		// 指示此转换器是否可以读取给定的类
		boolean canRead(Class<?> clazz, @Nullable MediaType mediaType);

		// 指示此转换器是否可以写入给定的类
		boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType);
		
		// 返回此转换器支持的MediaType对象列表。
		List<MediaType> getSupportedMediaTypes();
		
		// 从给定的输入消息中读取给定类型的对象，并返回它
		T read(Class<? extends T> clazz, HttpInputMessage inputMessage)
			throws IOException, HttpMessageNotReadableException;

		// 将给定对象写入给定的输出消息。
		void write(T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage)
			throws IOException, HttpMessageNotWritableException;

	}

```

#### RestTemplate 在 `HttpMessageConverter` 设计

同步客户端执行HTTP请求模板

```

	public class RestTemplate extends InterceptingHttpAccessor implements RestOperations {

		static {
			ClassLoader classLoader = RestTemplate.class.getClassLoader();
			romePresent = ClassUtils.isPresent("com.rometools.rome.feed.WireFeed", classLoader);
			jaxb2Present = ClassUtils.isPresent("javax.xml.bind.Binder", classLoader);
			jackson2Present =
					ClassUtils.isPresent("com.fasterxml.jackson.databind.ObjectMapper", classLoader) &&
							ClassUtils.isPresent("com.fasterxml.jackson.core.JsonGenerator", classLoader);
			jackson2XmlPresent = ClassUtils.isPresent("com.fasterxml.jackson.dataformat.xml.XmlMapper", classLoader);
			jackson2SmilePresent = ClassUtils.isPresent("com.fasterxml.jackson.dataformat.smile.SmileFactory", classLoader);
			jackson2CborPresent = ClassUtils.isPresent("com.fasterxml.jackson.dataformat.cbor.CBORFactory", classLoader);
			gsonPresent = ClassUtils.isPresent("com.google.gson.Gson", classLoader);
			jsonbPresent = ClassUtils.isPresent("javax.json.bind.Jsonb", classLoader);
		}

		private final List<HttpMessageConverter<?>> messageConverters = new ArrayList<>();

		public RestTemplate() {
			this.messageConverters.add(new ByteArrayHttpMessageConverter());
			this.messageConverters.add(new StringHttpMessageConverter());
			this.messageConverters.add(new ResourceHttpMessageConverter(false));
			try {
				this.messageConverters.add(new SourceHttpMessageConverter<>());
			}
			catch (Error err) {
				// Ignore when no TransformerFactory implementation is available
			}
			this.messageConverters.add(new AllEncompassingFormHttpMessageConverter());
	
			if (romePresent) {
				this.messageConverters.add(new AtomFeedHttpMessageConverter());
				this.messageConverters.add(new RssChannelHttpMessageConverter());
			}
	
			if (jackson2XmlPresent) {
				this.messageConverters.add(new MappingJackson2XmlHttpMessageConverter());
			}
			else if (jaxb2Present) {
				this.messageConverters.add(new Jaxb2RootElementHttpMessageConverter());
			}
	
			if (jackson2Present) {
				this.messageConverters.add(new MappingJackson2HttpMessageConverter());
			}
			else if (gsonPresent) {
				this.messageConverters.add(new GsonHttpMessageConverter());
			}
			else if (jsonbPresent) {
				this.messageConverters.add(new JsonbHttpMessageConverter());
			}
	
			if (jackson2SmilePresent) {
				this.messageConverters.add(new MappingJackson2SmileHttpMessageConverter());
			}
			if (jackson2CborPresent) {
				this.messageConverters.add(new MappingJackson2CborHttpMessageConverter());
			}
	
			this.uriTemplateHandler = initUriTemplateHandler();
		}

		public RestTemplate(List<HttpMessageConverter<?>> messageConverters) {
			Assert.notEmpty(messageConverters, "At least one HttpMessageConverter required");
			this.messageConverters.addAll(messageConverters);
			this.uriTemplateHandler = initUriTemplateHandler();
		}

	}

```


#### RestTemplate 扩展

`RestTemplate`中的方法`getForObject`，中的对象`HttpMessageConverterExtractor`，该class中的方法`extractData`

```

	public T extractData(ClientHttpResponse response) throws IOException {
		MessageBodyClientHttpResponseWrapper responseWrapper = new MessageBodyClientHttpResponseWrapper(response);
		if (!responseWrapper.hasMessageBody() || responseWrapper.hasEmptyMessageBody()) {
			return null;
		}
		MediaType contentType = getContentType(responseWrapper);

		try {
			for (HttpMessageConverter<?> messageConverter : this.messageConverters) {
				if (messageConverter instanceof GenericHttpMessageConverter) {
					GenericHttpMessageConverter<?> genericMessageConverter =
							(GenericHttpMessageConverter<?>) messageConverter;
					if (genericMessageConverter.canRead(this.responseType, null, contentType)) {
						if (logger.isDebugEnabled()) {
							ResolvableType resolvableType = ResolvableType.forType(this.responseType);
							logger.debug("Reading to [" + resolvableType + "]");
						}
						return (T) genericMessageConverter.read(this.responseType, null, responseWrapper);
					}
				}
				if (this.responseClass != null) {
					if (messageConverter.canRead(this.responseClass, contentType)) {
						if (logger.isDebugEnabled()) {
							String className = this.responseClass.getName();
							logger.debug("Reading to [" + className + "] as \"" + contentType + "\"");
						}
						return (T) messageConverter.read((Class) this.responseClass, responseWrapper);
					}
				}
			}
		}
		catch (IOException | HttpMessageNotReadableException ex) {
			throw new RestClientException("Error while extracting response for type [" +
					this.responseType + "] and content type [" + contentType + "]", ex);
		}

		throw new RestClientException("Could not extract response: no suitable HttpMessageConverter found " +
				"for response type [" + this.responseType + "] and content type [" + contentType + "]");
	}

```




##Netflix Ribbon
###负载均衡客户端
###负载均衡上下文
###负载均衡规则

## 扩展内容
AXB能够使用Jackson对JAXB注解的支持实现(jackson-module-jaxb-annotations)，既方便生成XML，也方便生成JSON，这样一来可以更好的标志可以转换为JSON对象的JAVA类。JAXB允许JAVA人员将JAVA类映射为XML表示方式，常用的注解包括：@XmlRootElement,@XmlElement等等。
JAXB（Java Architecture for XML Binding) 是一个业界的标准，是一项可以根据XML Schema产生Java类的技术。该过程中，JAXB也提供了将XML实例文档反向生成Java对象树的方法，并能将Java对象树的内容重新写到XML实例文档。从另一方面来讲，JAXB提供了快速而简便的方法将XML模式绑定到Java表示，从而使得Java开发者在Java应用程序中能方便地结合XML数据和处理函数。


