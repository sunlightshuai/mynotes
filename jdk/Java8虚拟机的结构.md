学习官方文档的笔记，具体内容参考官方文档

# Java虚拟机的结构

## 类文件格式

Java虚拟机要执行的已编译代码使用独立于硬件和操作系统的二进制格式表示，通常存储在称为类文件格式的文件中。 类文件格式精确地定义了类或接口的表示形式，包括诸如字节顺序之类的细节。

## 数据类型

Java虚拟机可对两种类型进行操作：原始类型和引用类型。相应地，可以将两种类型的值存储在变量中，作为参数传递，由方法返回并对其进行操作：原始值和参考值。

Java虚拟机希望几乎所有类型检查都在运行时之前完成，通常由编译器完成，而不必由Java虚拟机本身完成。基本类型的值不需要被标记或无需检查即可在运行时确定其类型，或与引用类型的值区分开。相反，Java虚拟机的指令集使用旨在对特定类型的值进行运算的指令来区分其操作数类型。例如，iadd，ladd，fadd和dadd都是Java虚拟机指令，它们添加两个数值并产生数值结果，但是每个指令都专门针对其操作数类型：int，long，float和double。

Java虚拟机包含对对象的显式支持。对象可以是动态分配的类实例，也可以是数组。对对象的引用被认为具有Java虚拟机类型引用。类型引用的值可以认为是指向对象的指针。可能存在对一个对象的多个引用。对象始终通过类型引用的值进行操作，传递和测试。

## 原始类型和值

Java虚拟机支持的原始数据类型是数字类型，布尔类型和returnAddress类型。

数值类型由整数类型和浮点类型组成。

整数类型为：

byte，其值为8位带符号的二进制补码整数，并且其默认值为零。

short，其值为16位带符号的二进制补码整数，其默认值为零。

int，其值为32位带符号的二进制补码整数，并且其默认值为零。

long，其值为64位带符号的二进制补码整数，并且其默认值为零。

char，其值是16位无符号整数，表示基本多语言平面中的Unicode代码点，并以UTF-16编码，其默认值为空代码点（'\ u0000'）

浮点类型为：

float，其值是float值集的元素，或者在受支持的情况下是float-extended-exponent值集的元素，其默认值为正零

double，其值是double值集的元素，或者在支持的情况下是double-extended-exponent值集的元素，其默认值为正零

boolean，对真值true和false进行编码，默认值为false。

returnAddress类型的值是指向Java虚拟机指令的操作码的指针。在原始类型中，只有returnAddress类型没有与Java编程语言类型直接关联。

### 整数类型和值

Java虚拟机的整数类型的值为：

byte，从-128到127（-27到27-1）（包括首尾）

short，从-32768到32767（-215到215-1）（含）

int，从-2147483648到2147483647（-231到231-1）（包括）

long，（从-9223372036854775808到9223372036854775807（-263到263-1）（包括）

char，范围为0至65535（含）

### 浮点类型，值集和值

浮点类型为float和double，它们在概念上与32位单精度和64位双精度格式的IEEE 754值以及IEEE二进制浮点算术标准（ANSI / IEEE）。

IEEE 754标准不仅包括正负号幅度数，而且还包括正零号和负零号，正负号和负无穷大以及特殊的非数字值（以下简称为“ NaN”）。 NaN值用于表示某些无效操作的结果，例如零除零。

Java虚拟机的每个实现都需要支持两个标准的浮点值集，称为浮点值集和双精度值集。另外，Java虚拟机的实现可以选择支持两个扩展指数浮点值集之一或全部，这两个集合称为float-extended-exponent值集和double-extended-exponent值集。在某些情况下，可以使用这些扩展指数值集代替标准值集来表示float或double类型的值。

### returnAddress类型和值

Java虚拟机的jsr，ret和jsr_w指令使用returnAddress类型。 returnAddress类型的值是指向Java虚拟机指令的操作码的指针。 与数字原始类型不同，returnAddress类型不与任何Java编程语言类型相对应，并且不能由正在运行的程序进行修改。

### 布尔类型

尽管Java虚拟机定义了布尔类型，但是它仅提供非常有限的支持。没有Java虚拟机指令专门用于布尔值的操作。相反，将对布尔值进行运算的Java编程语言中的表达式编译为使用Java虚拟机int数据类型的值。

Java虚拟机确实直接支持布尔数组。它的newarray指令（§newarray）可以创建布尔数组。使用字节数组指令baload和bastore（§baload，§bastore）访问和修改boolean类型的数组。

在Oracle的Java虚拟机实现中，将Java编程语言中的布尔数组编码为Java虚拟机字节数组，每个布尔元素使用8位。

Java虚拟机使用1表示true和0表示false来对布尔数组组件进行编码。如果编译器将Java编程语言的布尔值映射到Java虚拟机类型int的值，则编译器必须使用相同的编码。

## 参考类型和值

有三种引用类型：类类型，数组类型和接口类型。它们的值分别引用动态创建的类实例，数组或实现接口的类实例或数组。

数组类型由具有单个维度的组件类型组成（其长度未由类型指定）。数组类型的组件类型本身可以是数组类型。如果从任何数组类型开始，先考虑其组件类型，然后再考虑（如果也是数组类型）该类型的组件类型，依此类推，则最终必须达到不是数组类型的组件类型；这称为数组类型的元素类型。数组类型的元素类型必须是原始类型，类类型或接口类型。

引用值也可以是特殊的空引用，即无对象的引用，此处将以空表示。空引用最初没有运行时类型，但可以强制转换为任何类型。引用类型的默认值为null。

## 运行时数据区

Java虚拟机定义了在程序执行期间使用的各种运行时数据区域。 其中一些数据区域是在Java虚拟机启动时创建的，仅在Java虚拟机退出时才被销毁。 其他数据区域是每个线程的。 创建线程时创建每个线程的数据区域，并在线程退出时销毁每个数据区域。

### pc寄存器

Java虚拟机可以一次支持多个执行线程。 每个Java虚拟机线程都有其自己的pc寄存器。 在任何时候，每个Java虚拟机线程都在执行一个方法的代码，即该线程的当前方法。 如果该方法不是本机方法，则pc寄存器包含当前正在执行的Java虚拟机指令的地址。 如果线程当前正在执行的方法是本地方法，则Java虚拟机的pc寄存器的值未定义。 Java虚拟机的pc寄存器足够宽，可以在特定平台上保存returnAddress或本机指针。

### Java虚拟机堆栈

每个Java虚拟机线程都有一个私有Java虚拟机堆栈，与该线程同时创建。 Java虚拟机堆栈存储框架。 Java虚拟机堆栈类似于常规语言（例如C）的堆栈：它保存局部变量和部分结果，并在方法调用和返回中起作用。因为除了推送和弹出帧外，从不直接操纵Java虚拟机堆栈，所以可以为堆分配帧。 Java虚拟机堆栈的内存不必是连续的。

在Java虚拟机规范的第一版中，Java虚拟机堆栈称为Java堆栈。

该规范允许Java虚拟机堆栈具有固定大小，或者根据计算要求动态扩展和收缩。如果Java虚拟机堆栈的大小固定，则在创建每个Java虚拟机堆栈时可以独立选择其大小。

Java虚拟机实现可以为我们提供对Java虚拟机堆栈初始大小的控制，并且在动态扩展或收缩Java虚拟机堆栈的情况下，可以控制最大和最小大小。

以下异常条件与Java虚拟机堆栈相关：

如果线程中的计算需要比允许的Java虚拟机更大的堆栈，则Java虚拟机将引发StackOverflowError。

如果可以动态扩展Java虚拟机堆栈，并尝试进行扩展，但是可以提供足够的内存来实现扩展，或者如果没有足够的内存来为新线程创建初始Java虚拟机堆栈，则Java虚拟机机器抛出OutOfMemoryError。

### 堆

Java虚拟机具有一个在所有Java虚拟机线程之间共享的堆。堆是运行时数据区，从中分配所有类实例和数组的内存。

堆是在虚拟机启动时创建的。自动存储管理系统（称为垃圾收集器）可以回收对象的堆存储；对象永远不会显式释放。 Java虚拟机不假定特定类型的自动存储管理系统，可以根据实现者的系统要求选择存储管理技术。堆的大小可以是固定的，也可以根据计算的要求进行扩展，如果不需要更大的堆，则可以将其收缩。堆的内存不必是连续的。

Java虚拟机实现可以为我们提供对堆的初始大小的控制，并且，如果可以动态扩展或收缩堆，则可以控制最大和最小堆大小。

以下异常情况与堆相关联：

如果计算需要的堆多于自动存储管理系统可以提供的堆，则Java虚拟机将引发OutOfMemoryError。

### 方法区域

Java虚拟机具有一个在所有Java虚拟机线程之间共享的方法区域。该方法区域类似于常规语言的编译代码的存储区域，或者类似于操作系统过程中的“文本”段。它存储每个类的结构，例如运行时常量池，字段和方法数据，以及方法和构造函数的代码，包括用于类和实例初始化以及接口初始化的特殊方法。

方法区域是在虚拟机启动时创建的。尽管方法区域在逻辑上是堆的一部分，但是简单的实现可以选择不进行垃圾回收或压缩。该规范没有规定方法区域的位置或用于管理已编译代码的策略。方法区域可以是固定大小的，或者可以根据计算的需要进行扩展，如果不需要更大的方法区域，则可以缩小。方法区域的内存不必是连续的。

Java虚拟机实现可以为我们提供对方法区域初始大小的控制，以及在方法区域大小可变的情况下，可以控制最大和最小方法区域大小。

以下异常条件与方法区域相关联：

如果无法使方法区域中的内存可用以满足分配请求，则Java虚拟机将引发OutOfMemoryError。

###  运行时常量池

运行时常量池是类文件中constant_pool表的按类或按接口的运行时表示。它包含多种常量，范围从编译时已知的数字文字到必须在运行时解析的方法和字段引用。运行时常量池的功能类似于常规编程语言的符号表，尽管它包含的数据范围比典型的符号表还大。

每个运行时常量池都是从Java虚拟机的方法区域分配的。当Java虚拟机创建类或接口时，将为类或接口构造运行时常量池。

以下异常条件与类或接口的运行时常量池的构造有关：

创建类或接口时，如果运行时常量池的构造所需的内存超过Java虚拟机的方法区域中可用的内存，则Java虚拟机将引发OutOfMemoryError。

### 本地方法堆栈

Java虚拟机的实现可以使用传统的堆栈来支持本地方法。解释程序的实现也可以使用诸如C之类的语言来解释Java虚拟机的指令集，以使用本地方法栈。Java虚拟机实现不能加载本地方法并且自身不依赖于常规堆栈，因此无需提供本地方法堆栈。如果提供，通常在创建每个线程时为每个线程分配本地方法堆栈。

该规范允许本地方法堆栈具有固定大小，或者根据计算要求动态扩展和收缩。如果本地方法堆栈的大小固定，则在创建每个本地方法堆栈的大小时可以独立选择。

Java虚拟机实现可以为程序员或用户提供对本地方法堆栈的初始大小的控制，并且在本地方法堆栈大小变化的情况下，可以控制最大和最小方法堆栈大小。

以下异常条件与本地方法堆栈相关联：

如果线程中的计算所需的本地方法堆栈超出允许的范围，则Java虚拟机将引发StackOverflowError。

如果可以动态扩展本地方法堆栈并尝试进行本地方法堆栈扩展，但可以提供足够的内存，或者可以提供足够的内存来为新线程创建初始本地方法堆栈，则Java虚拟机将引发OutOfMemoryError 。

## 帧

帧用于存储数据和部分结果，以及执行动态链接，方法的返回值和调度异常。

每次调用方法时都会创建一个新帧。帧的方法调用完成时，无论该完成是正常的还是突然的（它引发未捕获的异常），它都会被销毁。帧是从创建帧的线程的Java虚拟机堆栈中分配的。每个帧都有其自己的局部变量数组，自己的操作数堆栈以及对当前方法类的运行时常量池的引用 。

可以使用其他特定于实现的信息（例如调试信息）来扩展帧。

局部变量数组和操作数堆栈的大小在编译时确定，并与与帧关联的方法的代码一起提供。因此，帧数据结构的大小仅取决于Java虚拟机的实现，并且可以在方法调用时同时分配用于这些结构的内存。

在给定的控制线程中，只有一帧（用于执行方法的帧）在任何时候都处于活动状态。该帧称为当前帧，其方法称为当前方法。定义当前方法的类是当前类。局部变量和操作数堆栈上的操作通常参考当前帧。

如果帧的方法调用另一个方法或该帧的方法完成，则该帧将不再是当前帧。调用方法时，将创建新帧，并在控制权转移到新方法时变为新帧。在方法返回时，当前帧将其方法调用的结果（如果有的话）传递回前一帧。当前一帧变为当前帧时，当前帧将被丢弃。

请注意，由线程创建的框架在该线程本地，并且不能被任何其他线程引用。

### 局部变量

每个帧都包含一个称为其局部变量的变量数组。帧的局部变量数组的长度在编译时确定，并以类或接口的二进制表示形式以及与帧关联的方法的代码提供。

单个局部变量可以包含布尔值，字节，字符，短型，整数，浮点型，引用或returnAddress类型的值。一对局部变量可以容纳long或double类型的值。

局部变量通过索引解决。第一个局部变量的索引为零。当且仅当该整数比局部变量数组的大小小零至一之间时，该整数才被视为局部变量数组的索引。

long类型或double类型的值占用两个连续的局部变量。只能使用较小的索引来解决该值。例如，存储在索引为n的局部变量数组中的double类型的值实际上占据了索引为n和n + 1的局部变量。但是，无法从索引n + 1加载局部变量。它可以存储到。但是，这样做会使局部变量n的内容无效。

Java虚拟机不需要n为偶数。用直观的术语来说，long和double类型的值不需要在局部变量数组中进行64位对齐。实现者可以使用为值保留的两个局部变量自由决定表示此类值的适当方式。

Java虚拟机使用局部变量在方法调用时传递参数。在类方法调用中，所有参数都从局部变量0开始在连续的局部变量中传递。在实例方法调用中，局部变量0始终用于将引用传递给在其上调用实例方法的对象（在Java中，这是编程语言）。随后将任何参数传递到从局部变量1开始的连续局部变量中。

### 操作数栈

每个帧包含后进先出（LIFO ）堆栈，称为*操作数堆栈*。帧最大操作数堆栈深度是在编译时确定的，并与帧相关的方法的代码一起提供。

在上下文清楚的地方，我们有时将当前帧的操作数堆栈简称为操作数堆栈。

创建包含操作数堆栈的帧时，该操作数堆栈为空。 Java虚拟机提供了将局部变量或字段中的常量或值加载到操作数堆栈上的指令。其他Java虚拟机指令从操作数堆栈中获取操作数，对其进行操作，然后将结果压回操作数堆栈。操作数堆栈还用于准备要传递给方法的参数并接收方法结果。

例如，*iadd*指令添加两个“int”值在一起。它要求将“int”值添加为操作数堆栈的前两个值，并由前面的指令压入该值。这两个int值都从操作数堆栈中弹出。将它们相加，然后将它们的总和推回操作数堆栈。子计算可嵌套在操作数堆栈上，从而产生可被包含计算使用的值。

操作数堆栈上的每个条目都可以包含任何Java虚拟机类型的值，包括“long”类型或“double”类型的值。

操作数堆栈中的值必须以适合其类型的方式进行操作。例如，不可能推入两个“int”值，然后将它们视为“long”，或推入两个“float”值，然后使用*iadd*指令将它们相加。少量Java虚拟机指令（*dup*指令和*swap*指令）在运行时数据区域上将其作为原始值，而不考虑其特定类型；这些指令的定义方式不能用于修改或分解单个值。这些对操作数堆栈操作的限制是通过`class`文件验证来强制执行的。

在任何时间点，操作数堆栈都具有关联的深度，其中“long”或“double”类型的值对该深度贡献两个单位，而任何其他类型的值都对深度贡献一个单位。

### 动态链接

每个帧都包含对运行时常量池的引用以支持当前方法的类型*方法代码的动态链接*。 方法的“类”文件代码是指要调用的方法和要通过符号引用访问的变量。 动态链接将这些符号方法引用转换为具体的方法引用，根据需要加载类以解析尚未定义的符号，并将变量访问转换为与这些变量的运行时位置关联的存储结构中的适当偏移量。

方法和变量的后期绑定使方法使用的其他类的更改不太可能破坏此代码。

### 普通方法调用完成

如果该方法调用不会引起异常，可以直接从Java虚拟机或执行显式的`throw`语句抛出。如果当前方法的调用正常完成，则可以将值返回给调用方法。当调用的方法执行返回指令，其选择必须适合要返回的值的类型。

在这种情况下，使用当前帧的调用程序，包括它的局部变量和操作数堆栈，调用程序的程序计数器适当增加，以跳过方法调用指令。然后，执行通常在调用方法的框架中继续进行，并将返回值（如果有）压入该框架的操作数堆栈。

### 突然的方法调用完成

如果在方法中执行Java虚拟机指令导致Java虚拟机引发异常，并且该方法未处理该异常。 执行*athrow*指令也将导致要显式抛出的异常，如果当前方法未捕获到该异常，则会导致突然的方法调用完成。 突然完成的方法调用永远不会向其调用者返回值。

## 对象的表示

Java虚拟机不要求对象具有任何特定的内部结构。

在Oracle对Java虚拟机的一些实现中，对类实例的引用是指向*handle*的指针，该指针本身是一对指针：一个指向包含对象的方法的表和指向'Class'的指针对象代表对象的类型（对象头），另一个代表从堆为对象数据分配的内存。

## 浮点运算

Java虚拟机包含*IEEE*二进制浮点算术标准（ANSI / IEEE标准754-1985，纽约）中指定的浮点算术的子集。

### Java虚拟机浮点算法和IEEE 754

- Java虚拟机和IEEE 754标准支持的浮点算法之间的主要区别是：

  - Java虚拟机的浮点操作不会引发异常，表明IEEE 754无效操作，被零除，上溢，下溢或不精确的特殊情况。 Java虚拟机没有信令NaN值。

  - Java虚拟机不支持IEEE 754信令浮点比较。

  - Java虚拟机的舍入操作始终使用IEEE 754舍入到最近模式。不精确的结果四舍五入到最接近的可表示值，并用最低有效位为零的值舍入。这是IEEE 754的默认模式。但是，将浮点类型的值转换为整数类型的值的Java虚拟机指令四舍五入为零。 Java虚拟机不提供任何更改浮点舍入模式的方法。

  - Java虚拟机不支持IEEE 754单一扩展格式或双重扩展格式，除非可以说double和double-extended-exponent值集支持单一扩展格式。可以可选地支持的float扩展指数和double扩展指数值集不对应于IEEE 754扩展格式的值：IEEE 754扩展格式需要扩展的精度以及扩展的指数范围。

### 浮点模式

每个方法都有一个*浮点模式*。方法的浮点模式由“method_info”结构的“access_flags”项的“ACC_STRICT”标志的设置决定定义方法。设置此标志的方法是FP-strict；否则，该方法不受FP限制。

请注意，`ACC_STRICT`标志的映射意味着JDK 1.1或更早版本中的编译器编译的类中的方法实际上不受FP限制。

当调用创建包含该操作数堆栈的帧的方法具有该浮点模式时，我们将把操作数堆栈称为具有给定的浮点模式。同样，当包含该指令的方法具有该浮点模式时，我们会将Java虚拟机指令称为具有给定的浮点模式。

如果支持浮点扩展指数值集，则在不受FP限制的操作数堆栈上，类型为'float'的值可能会超出该值集，除非值集转换禁止。如果支持双扩展指数值集，在不受FP限制的操作数堆栈上，类型为'double'的值可能超出该值集，除非值集转换禁止。

在所有其他上下文中，无论是在操作数堆栈上还是在其他位置，无论浮点模式如何，“float”和“double”类型的浮点值都只能分别位于float值集和double值集的范围内。特别是，类和实例字段，数组元素，局部变量和方法参数只能包含从标准值集中得出的值。

### 值集转换

在特定情况下，允许或要求支持扩展浮点值集的Java虚拟机实现在映射的扩展值和标准值集之间映射关联的浮点类型的值。这样的“值集转换”不是类型转换，而是与相同类型关联的值集之间的映射。

在指示值集转换的地方，允许实现对值执行以下操作之一：

- 如果该值是`float`类型且不是float值集的元素，则将值映射到float值集的最接近元素。

- 如果值是double类型的值，并且不是double值集的元素，则它将值映射到double值集的最接近元素。

另外，在指示值集转换的地方，需要某些操作：

- 假设执行非FP严格限制的Java虚拟机指令，将类型“float”的值压入FP严格限制的操作数堆栈，作为参数传递或存储到局部变量（字段）中，或数组的元素。如果该值不是浮点值集的元素，则它将值映射到浮点值集的最接近元素。

- 假设执行非FP严格限制的Java虚拟机指令，会导致将类型为double的值压入FP严格限制的操作数堆栈，作为参数传递或存储到局部变量字段中，或数组的元素。如果该值不是双精度值集的元素，则它将值映射到双精度值集的最接近元素。

这种要求的值集转换可能是由于在方法调用（包括“本地”方法调用）期间传递浮点类型的参数而导致的。从非FP-strict的方法返回到FP-strict的方法的浮点类型的值；或以不受FP限制的方法将浮点类型的值存储到局部变量，字段或数组中。

并非扩展指数值集中的所有值都可以精确映射到相应标准值集中的值。如果要映射的值太大而无法准确表示（其指数大于标准值集所允许的指数），则将其转换为相应类型的（正或负）无穷大。如果要映射的值太小而无法精确表示（其指数小于标准值集所允许的指数），则将其舍入为可表示的非规范化值的最接近值或相同符号的零。

值集转换保留无穷大和NaN，并且不能更改要转换的值的符号。值集转换对非浮点类型的值没有影响。

## 特殊方法

在Java虚拟机的级别上，用Java编程语言编写的每个构造函数都将作为具有特殊名称“<init>”的“实例初始化方法” 出现。该名称由编译器提供。因为名称 “<init>”不是有效的标识符，所以不能直接用Java编程语言编写的程序中使用它。实例初始化方法只能在Java虚拟机中通过*invokespecial*指令，并且只能在未初始化的类实例上调用它们。实例初始化方法具有从其获得构造函数的访问权限。

一个类或接口最多具有一个类或接口初始化方法并被初始化。类或接口的初始化方法具有特殊名称`<clinit>`，不带参数，并且是无效的。

在`class`文件中名为`<clinit>`的其他方法无关紧要。它们不是类或接口的初始化方法。它们不能被任何Java虚拟机指令调用，也不能被Java虚拟机本身调用。

在版本号为51.0或更高版本的“class”文件中，该方法还必须具有其“ACC_STATIC”标志设置为类或接口的初始化方法。

此要求是在Java SE 7中引入的。在版本号为50.0或更低的类文件中，名为`<clinit>`且无效且不带任何参数的方法被视为类或接口初始化方法，无论其设置如何ACC_STATIC标志。

名称“ <clinit>”由编译器提供。由于名称“ <clinit>”不是有效的标识符，因此不能直接用Java编程语言编写的程序中使用它。类和接口初始化方法由Java虚拟机隐式调用。绝对不能从任何Java虚拟机指令直接调用它们，而只能在类初始化过程中间接调用它们。

如果满足以下所有条件，则方法为“签名多态”：

- 在`java.lang.invoke.MethodHandle`类中声明。

- 它具有类型为Object []的单个形式参数。

- 返回类型为“对象”。

- 它设置了`ACC_VARARGS`和`ACC_NATIVE`标志。

在Java SE 8中，唯一的签名多态方法是类java.lang.invoke.MethodHandle的invoke和invokeExact方法。

Java虚拟机对*invokevirtual*指令，以实现*方法句柄*的调用。方法句柄是对基础方法，构造函数，字段或类似的低级操作的强类型，直接可执行的引用，以及参数或返回值的可选转换。这些转换非常普遍，并且包括诸如转换，插入，删除和替换之类的模式。有关更多信息，请参见Java SE平台API中的`java.lang.invoke`包。

## 异常

Java虚拟机中的异常由Throwable类或其子类之一的实例表示。引发异常会导致从引发异常的那一刻起立即进行非本地控制转移。

大多数异常是由于发生它们的线程采取的措施而同步发生的。相反，异步异常可能在程序执行的任何时候发生。 Java虚拟机引发异常是由于以下三个原因之一：

- 执行了*athrow*指令。

- Java虚拟机同步检测到异常执行条件。这些异常不会在程序中的任意位置抛出，而只会在执行以下任一指令后才同步：
     - 将异常指定为可能的结果，例如:
       - 当指令体现的操作违反Java编程语言的语义时，例如，在数组范围之外进行索引。

       - 加载或链接程序的一部分时发生错误
     - 导致超出某些资源限制，例如，在使用过多内存时。

- 发生异步异常是因为：

  - 调用了“线程”或“线程组”类的“停止”方法
  - Java虚拟机实现中发生内部错误。

  一个线程可以调用“stop”方法来影响另一个线程或指定线程组中的所有线程。它们是异步的，因为它们可能在其他一个或多个线程的执行中的任何时刻发生。内部错误被视为异步错误。

Java虚拟机可以允许在引发异步异常之前执行少量但有限的执行。允许使用此延迟，以使优化的代码可以在遵循Java编程语言的语义的情况下在切实可行的位置检测并抛出这些异常。

一个简单的实现可以在每个控制传递指令的位置轮询异步异常。由于程序的大小是有限的，因此这在检测异步异常方面为总延迟提供了限制。由于在控制传输之间不会发生异步异常，因此代码生成器具有一些灵活性，可以在控制传输之间对计算进行重新排序，以提高性能。

Java虚拟机引发的异常是精确的：当发生控制转移时，在抛出异常的那一点之前执行的指令的所有效果必须看起来已经发生。引发异常后的任何指令似乎都没有被评估。如果优化的代码已经推测性地执行了发生异常之后的某些指令，则必须准备此类代码以使该推测性执行对程序的用户可见状态隐藏。

Java虚拟机中的每个方法都可能与零个或多个*异常处理程序*相关联。异常处理程序指定实现该异常处理程序所针对的方法的Java虚拟机代码中的偏移量范围，描述该异常处理程序能够处理的异常类型，并指定要处理的代码的位置那个例外。如果引起异常的指令的偏移量在异常处理程序的偏移量范围内，并且异常类型与异常处理程序处理的异常属于同一类或该异常类的子类，则该异常与异常处理程序匹配。引发异常时，Java虚拟机将在当前方法中搜索匹配的异常处理程序。如果找到匹配的异常处理程序，则系统分支到由匹配的处理程序指定的异常处理代码。

如果在当前方法中未找到此类异常处理程序，则当前方法调用将完成。完成时，当前方法调用的操作数堆栈和局部变量将被丢弃，并弹出其框架，以恢复调用方法的框架。然后，在调用者框架的上下文中抛出该异常，依此类推，继续执行方法调用链。如果在到达方法调用链的顶部之前未找到合适的异常处理程序，则终止在其中引发异常的线程的执行。

搜索方法的异常处理程序以查找匹配项的顺序很重要。在一个“class”文件中，每种方法的异常处理程序都存储在一个表中。在运行时，当引发异常时，Java虚拟机从当前方法的异常处理程序出现在“class”文件的相应异常处理程序表中的顺序开始搜索，从该表的开头开始。

注意，Java虚拟机不强制方法的异常表条目的嵌套或任何顺序。 Java编程语言的异常处理语义仅通过与编译器。当通过其他方式生成`class`文件时，定义的搜索过程将确保所有Java虚拟机实现均具有一致的行为。

## 指令集摘要

Java虚拟机指令由一个字节的*opcode*指定要执行的操作，然后由零个或多个*operands*提供操作所使用的参数或数据组成。 许多指令没有操作数，仅由操作码组成。

忽略异常，Java虚拟机解释器的内部循环是有效的。

```java
do {
    atomically calculate pc and fetch opcode at pc;
    if (operands) fetch operands;
    execute the action for the opcode;
} while (there is more to do);
```

操作数的数量和大小由操作码确定。 如果操作数的大小超过一个字节，则将其以“big-endian”顺序存储-首先是高字节。 例如，局部变量的无符号16位索引存储为两个无符号字节*byte1*和*byte2*，因此其值为（*byte1*`<<`8）| *byte2*。

字节码指令流仅单字节对齐。 这两个例外是*lookupswitch*和*tableswitch*指令，将其强制填充它们的某些操作数在4字节边界上的内部对齐。

将Java虚拟机操作码限制为一个字节并放弃已编译代码中的数据对齐的决定反映了倾向于紧凑性的有意识偏见，这可能以幼稚的实现为代价。 一字节的操作码也限制了指令集的大小。 不假定数据对齐意味着在许多机器上，运行时必须从字节构造大于字节的立即数据。

### 类型和Java虚拟机

Java虚拟机指令集中的大多数指令都对有关它们执行的操作的类型信息进行编码。例如，*iload*指令加载在操作数堆栈上的局部变量（必须为int）的内容。 *fload*指令的作用与浮动值。两条指令可能具有相同的实现，但具有不同的操作码。

对于大多数类型的指令，指令类型在操作码助记符中用字母显式表示：*i*表示`int`操作，*l*表示`long`，*s*表示`short`，*b*表示“字节”，*c*表示“char”，*f*表示“ float”，*d*表示“double”和*a*表示“引用”。类型明确的某些指令的助记符中没有类型字母。例如，*arraylength*始终对作为数组的对象进行操作。某些指令，例如*goto*（无条件控制传递），不能对类型化的操作数进行运算。

考虑到Java虚拟机的一字节操作码大小，将编码类型转换为操作码会给其指令集的设计带来压力。如果每个键入的指令都支持Java虚拟机的所有运行时数据类型，那么指令的数量将超出字节表示的数量。相反，Java虚拟机的指令集为某些操作提供了降低级别的类型支持。换句话说，指令集有意不正交。必要时，可以使用单独的指令在不受支持的数据类型和受支持的数据类型之间进行转换。

如下图总结了指令中的类型支持Java虚拟机的集合。通过将操作码列的指令模板中的*T*替换为类型列中的字母，可以构建具有类型信息的特定指令。如果某个指令模板的类型列和类型为空，则不存在支持该操作类型的指令。例如，有一个类型为“ int”的加载指令，*iload*，但是没有类型为“byte”的加载指令。

请注意，下图中的大多数说明都没有具有整数类型`byte`，`char`和`short`的形式。没有一个具有布尔类型的形式。编译器使用Java虚拟机指令对“byte”和“short”类型的文字值的负载进行编码，这些指令在编译时或运行时将这些值符号扩展为“ int”类型的值。类型为boolean和char的文字值的加载使用指令进行编码，这些指令在编译时或运行时将文字零扩展为类型为int的值。同样，使用Java虚拟机指令对boolean，short，byte，short和byte的值数组中的负载进行编码，这些指令对值进行符号扩展或零扩展为类型为int的值。因此，对实际类型为“boolean”，“byte”，“char”和“short”的值的大多数操作是通过对计算类型为“ int”的值进行操作的指令正确执行的。



**Java虚拟机指令集中的类型支持**

| opcode      | `byte`    | `short`   | `int`       | `long`    | `float`   | `double`  | `char`    | `reference` |
| ----------- | --------- | --------- | ----------- | --------- | --------- | --------- | --------- | ----------- |
| *Tipush*    | *bipush*  | *sipush*  |             |           |           |           |           |             |
| *Tconst*    |           |           | *iconst*    | *lconst*  | *fconst*  | *dconst*  |           | *aconst*    |
| *Tload*     |           |           | *iload*     | *lload*   | *fload*   | *dload*   |           | *aload*     |
| *Tstore*    |           |           | *istore*    | *lstore*  | *fstore*  | *dstore*  |           | *astore*    |
| *Tinc*      |           |           | *iinc*      |           |           |           |           |             |
| *Taload*    | *baload*  | *saload*  | *iaload*    | *laload*  | *faload*  | *daload*  | *caload*  | *aaload*    |
| *Tastore*   | *bastore* | *sastore* | *iastore*   | *lastore* | *fastore* | *dastore* | *castore* | *aastore*   |
| *Tadd*      |           |           | *iadd*      | *ladd*    | *fadd*    | *dadd*    |           |             |
| *Tsub*      |           |           | *isub*      | *lsub*    | *fsub*    | *dsub*    |           |             |
| *Tmul*      |           |           | *imul*      | *lmul*    | *fmul*    | *dmul*    |           |             |
| *Tdiv*      |           |           | *idiv*      | *ldiv*    | *fdiv*    | *ddiv*    |           |             |
| *Trem*      |           |           | *irem*      | *lrem*    | *frem*    | *drem*    |           |             |
| *Tneg*      |           |           | *ineg*      | *lneg*    | *fneg*    | *dneg*    |           |             |
| *Tshl*      |           |           | *ishl*      | *lshl*    |           |           |           |             |
| *Tshr*      |           |           | *ishr*      | *lshr*    |           |           |           |             |
| *Tushr*     |           |           | *iushr*     | *lushr*   |           |           |           |             |
| *Tand*      |           |           | *iand*      | *land*    |           |           |           |             |
| *Tor*       |           |           | *ior*       | *lor*     |           |           |           |             |
| *Txor*      |           |           | *ixor*      | *lxor*    |           |           |           |             |
| *i2T*       | *i2b*     | *i2s*     |             | *i2l*     | *i2f*     | *i2d*     |           |             |
| *l2T*       |           |           | *l2i*       |           | *l2f*     | *l2d*     |           |             |
| *f2T*       |           |           | *f2i*       | *f2l*     |           | *f2d*     |           |             |
| *d2T*       |           |           | *d2i*       | *d2l*     | *d2f*     |           |           |             |
| *Tcmp*      |           |           |             | *lcmp*    |           |           |           |             |
| *Tcmpl*     |           |           |             |           | *fcmpl*   | *dcmpl*   |           |             |
| *Tcmpg*     |           |           |             |           | *fcmpg*   | *dcmpg*   |           |             |
| *if_TcmpOP* |           |           | *if_icmpOP* |           |           |           |           | *if_acmpOP* |
| *Treturn*   |           |           | *ireturn*   | *lreturn* | *freturn* | *dreturn* |           | *areturn*   |

下图总结了Java虚拟机实际类型和Java虚拟机计算类型之间的映射。

某些Java虚拟机指令（例如*pop*和*swap*）在操作数堆栈上进行操作，而与类型无关。 但是，此类指令仅可用于某些类别的计算类型的值，如下图。

**Java虚拟机中的实际和计算类型**

| 实际类型        | 计算类型        | 类别 |
| --------------- | --------------- | ---- |
| `boolean`       | `int`           | 1    |
| `byte`          | `int`           | 1    |
| `char`          | `int`           | 1    |
| `short`         | `int`           | 1    |
| `int`           | `int`           | 1    |
| `float`         | `float`         | 1    |
| `reference`     | `reference`     | 1    |
| `returnAddress` | `returnAddress` | 1    |
| `long`          | `long`          | 2    |
| `double`        | `double`        | 2    |



### 加载和存储说明

加载和存储指令在局部变量之间传递值和Java的操作数堆栈虚拟机框架：

- 将局部变量加载到操作数堆栈上：*iload*，*iload_<n>*，*lload*，*lload_<n>*，*fload*，*fload_<n>*，*dload*，*dload_<n>*，*aload*，*aload_<n>*。
- 将操作数堆栈中的值存储到局部变量中：*istore*，*istore_<n>*，*lstore*，*lstore_<n>*，*fstore*，*fstore_<n>*，*dstore*，*dstore_<n>*，*astore*，*astore_<n>*
- Load a constant on to the operand stack: *bipush*, *sipush*, *ldc*, *ldc_w*, *ldc2_w*, *aconst_null*, *iconst_m1*, *iconst_<i>*, *lconst_<l>*, *fconst_<f>*, *dconst_<d>*.
- 将常量加载到操作数堆栈上：*bipush*，*sipush*，*ldc*，*ldc_w*，*ldc2_w*，*aconst_null*，*iconst_m1*，*iconst_<i>*，*lconst_ <l>* ，*fconst_<f>*，*dconst_<d>*。
- 使用更大的索引访问更大的局部变量，或者访问更大的立即数：*wide*。

访问对象和数组元素字段的指令还会在操作数堆栈之间传输数据。

上面显示的指令助记符，在尖括号之间带有结尾字母（例如*iload_<n>*），表示指令族（带有成员*iload_0*，*iload_1*，*iload_2*和*iload_3*，对于*iload_<n>*）。这些指令族是采用一个操作数的附加通用指令（*iload*）的专业化。对于专用指令，操作数是隐式的，不需要存储或提取。否则语义是相同的（*iload_0*与*iload*的操作数为*0*的含义相同）。尖括号之间的字母指定该系列指令的隐式操作数的类型：*<n>*为非负整数；对于*<i>*，一个`int`;对于*<l>*，为'long'；对于*<f>*，是`float`；对于*<d>*，为`double'。类型为int的表单在许多情况下用于对类型为byte，char和short的值执行操作。	

### 算术指令

算术指令计算的结果通常是操作数堆栈上两个值的函数，将结果推回到操作数堆栈上。 算术指令主要有两种：对整数值进行运算的指令和对浮点值进行运算的指令。 在每种类型中，算术指令专用于Java虚拟机数字类型。 不直接支持对“byte”，“short”和“char”类型，或者使用"boolean"的值； 这些操作由对类型为“int”的指令进行处理。 整数指令和浮点指令在溢出和被零除时的行为也有所不同。 算术指令如下：

- 加: *iadd*, *ladd*, *fadd*, *dadd*.
- 减: *isub*, *lsub*, *fsub*, *dsub*.
- 乘: *imul*, *lmul*, *fmul*, *dmul*.
- 除: *idiv*, *ldiv*, *fdiv*, *ddiv*.
- 取余: *irem*, *lrem*, *frem*, *drem*.
- 取反: *ineg*, *lneg*, *fneg*, *dneg*.
- 移位: *ishl*, *ishr*, *iushr*, *lshl*, *lshr*, *lushr*.
- 按位或: *ior*, *lor*.
- 按位与: *iand*, *land*.
- 按位异或: *ixor*, *lxor*.
- 局部变量增量: *iinc*.
- 比较: *dcmpg*, *dcmpl*, *fcmpg*, *fcmpl*, *lcmp*.

Java虚拟机指令集的语义直接支持Java编程语言运算符对整数和浮点值的语义。

在对整数数据类型进行操作期间，Java虚拟机不指示溢出。唯一可以引发异常的整数运算是整数除法指令（*idiv*和*ldiv*）和整数余数指令（*irem*和*lrem*），如果除数为零，则抛出“ArithmeticException”。

浮点数上的Java虚拟机操作的行为符合IEEE 754中的规定。特别地，Java虚拟机需要对IEEE 754的完全支持，即“非规范化”浮点数和“渐进下溢”，这使得证明所需的属性变得更加容易。特殊的数值算法。

Java虚拟机要求浮点运算的行为就像每个浮点运算符将其浮点结果四舍五入到结果精度一样。 *不精确*结果必须四舍五入到最接近无限精确结果的可表示值；如果两个最接近的可表示值都相等，则选择最低有效位为零的那个。这是IEEE 754标准的默认舍入模式，称为*舍入到最近*模式。

当将浮点值转换为整数时，Java虚拟机使用IEEE 754 *向零舍入*模式。这导致数字被截断；表示操作数值的小数部分的有效位的任何位都将被丢弃。向零取整模式选择的结果是类型值最接近但幅度不超过无限精确结果的类型。

Java虚拟机的浮点运算符不会引发运行时异常（不要与IEEE 754浮点异常混淆）。溢出的操作将产生有符号的无穷大，下溢的操作将产生非规范化的值或有符号的零，而数学上没有确定结果的操作将产生NaN。将NaN作为操作数的所有数值运算都会产生NaN。

对long类型（*lcmp*）类型的值进行比较会执行带符号的比较。使用IEEE 754非信令比较对浮点类型（*dcmpg*，*dcmpl*，*fcmpg*，*fcmpl*）的值进行比较。

### 类型转换说明

类型转换指令允许在Java虚拟机数字类型之间进行转换。 这些可用于实现用户代码中的显式转换或减轻Java虚拟机的指令集中缺乏正交性的情况。

Java虚拟机直接支持以下扩展的数字转换：

- `int` to `long`, `float`, or `double`
- `long` to `float` or `double`
- `float` to `double`

扩展数字转换指令为*i2l*，*i2f*，*i2d*，*l2f*，*l2d*和*f2d*。 考虑到类型化指令的命名约定以及将2表示“to”的修饰用法，这些操作码的助记符非常简单。 例如，*i2d*指令将“int”值转换为“double”。

大多数扩展的数值转换不会丢失有关数值整体大小的信息。 实际上，从int到long的转换以及从int到double的转换根本不会丢失任何信息。 数值将精确保留。 受FP限制的从“浮动”扩展到“双重”的转换也精确保留数值；仅不受FP限制的此类转换可能会丢失有关转换值整体大小的信息。

从int到float的转换，或者从long到float的转换，或者从long到double的转换，可能会丢失*precision*，也就是说，可能会丢失该值的某些最低有效位 ; 使用IEEE 754舍入到最接近的模式时，得到的浮点值是整数值的正确舍入版本。

尽管可能会发生精度损失，但是扩大数字转换范围决不会导致Java虚拟机抛出运行时异常（不要与IEEE 754浮点异常相混淆）。

将“int”扩展为“long”的数字转换只是对“int”值的二进制补码表示进行符号扩展，以填充更宽的格式。 将char扩展为整数类型的数字转换将对char值的表示形式进行零扩展以填充更宽的格式。

从整数类型“字节”，“字符”和“短”到“整数”类型的数字转换不存在。“byte”类型的值 在内部将`char`和`short`扩展为int类型，使这些转换隐式进行。

Java虚拟机还直接支持以下缩小的数字转换：

- `int` to `byte`, `short`, or `char`
- `long` to `int`
- `float` to `int` or `long`
- `double` to `int`, `long`, or `float`

缩小的数值转换指令是*i2b*，*i2c*，*i2s*，*l2i*，*f2i*，*f2l*，*d2i*，*d2l*和*d2f*。 缩小的数字转换可能会导致值的符号不同，数量级不同或两者兼而有之； 因此可能会失去精度。

将'int'或'long'缩小为整数类型T会简单地丢弃除*n*最低位以外的所有位，其中*n*是用于表示类型T的位数。这可能会导致 结果值与输入值的符号不同。

在将浮点值缩小为整数类型T的数字转换中，其中T为“ int”或“long”，浮点值的转换如下：

- 如果浮点值为NaN，则转换结果为“ int”或“ long” “0”。
- 否则，如果浮点值不是无穷大，则使用IEEE 754向零模式舍入将浮点值舍入为整数值*V*。 有两种情况：
  - 如果T为“ long”，并且该整数值可以表示为“long”，则结果为“long”值*V*。
  - 如果T为“int”类型，并且该整数值可以表示为“int”，则结果为“int”值*V*。
- 除此以外:
  - 该值必须太小（负值较大或负无穷大），结果是int或long类型的最小可表示值。
  - 或该值必须太大（正值较大或正无穷大），结果是类型为int或long的最大可表示值。

从“double”到“float”的变窄数字转换的行为符合IEEE754。使用IEEE 754四舍五入到最接近的模式可以正确舍入结果。 太小而无法表示为“ float”的值将转换为“ float”类型的正零或负零； 太大而无法表示为“float”的值将转换为正或负无穷大。 “double” NaN始终会转换为“float” NaN。

尽管可能会发生溢出，下溢或精度损失，但缩小数字类型之间的转换决不会导致Java虚拟机引发运行时异常（不要与IEEE 754浮点异常相混淆）。

### 对象创建和操作

尽管类实例和数组都是对象，但是Java虚拟机使用不同的指令集创建和操作类实例和数组：

- 创建一个新的类实例：*new*。
- 创建一个新数组：*newarray*，*anewarray*，*multianewarray*。
- 类的访问字段（“静态”字段，称为类变量）和类实例的字段（非“静态”字段，称为实例变量）：*getstatic*，*putstatic*，*getfield*，*putfield*。
- 将数组组件加载到操作数堆栈上：*baload*，*caload*，*saload*，*iaload*，*laload*，*faload*，*daload*，*aaload*。
- 将操作数堆栈中的值存储为数组组件：*bastore*，*castore*，*sastore*，*iastore*，*lastore*，*fastore*，*dastore*，*aastore*。
- 获取数组的长度：*arraylength*。
- 检查类实例或数组的属性：*instanceof*，*checkcast*。

### 操作数堆栈管理说明

提供了用于直接操作操作数堆栈的许多指令：*pop*，*pop2*，*dup*，*dup2*，*dup_x1*，*dup2_x1*，*dup_x2*，*dup2_x2*，*交换* 。

### 控制转移说明

控制转移指令有条件或无条件地使Java虚拟机继续执行除控制转移指令之后的另一条指令。 他们是：

- 条件分支：*ifeq*，*ifne*，*iflt*，*ifle*，*ifgt*，*ifge*，*ifnull*，*ifnonnull*，*if_icmpeq*，*if_icmpne*，*if_icmplt*，*if_icmple* ，*if_icmpgt*, *if_icmpge*，*if_acmpeq*，*if_acmpne*。
- 复合条件分支：*tableswitch*，*lookupswitch*。
- Unconditional branch: *goto*, *goto_w*, *jsr*, *jsr_w*, *ret*.
- 无条件分支：*goto*，*goto_w*，*jsr*，*jsr_w*，*ret*。

Java虚拟机具有不同的指令集，这些指令集有条件地与“ int”和“ reference”类型的数据进行比较。它还具有用于测试null引用的独特的条件分支指令，因此不需要为`null`指定具体值。

使用“ int”比较指令，在“boolean”，“byte”，“char”和“short”类型的数据之间进行比较的条件分支。使用比较数据并产生比较结果int的指令来启动对long类型，float类型或double类型的数据进行比较的条件分支。随后的“int”比较指令将测试此结果并影响条件分支。由于Java虚拟机强调“int”比较，因此为“int”类型提供了丰富的条件分支指令补充。

所有“ int”条件控制转移指令均执行带符号的比较。

### 方法调用和返回说明

以下五个指令调用方法：

- *invokevirtual*调用对象的实例方法，并根据对象的（虚拟）类型进行分派。 这是Java编程语言中的常规方法分派。
- *invokeinterface*调用接口方法，搜索由特定运行时对象实现的方法以找到适当的方法。
- *invokespecial*调用需要特殊处理的实例方法，而不管实例初始化方法，“private”方法或超类方法。
- *invokestatic*调用命名类中的类（“static”）方法。
- *invokedynamic*调用方法，该方法是绑定到*invokedynamic*指令的调用站点对象的目标。 由于在第一次执行该指令之前运行了引导程序方法，Java虚拟机将调用站点对象绑定到了*invokedynamic*指令的特定词法出现。 因此，与其他调用方法的指令不同，每次“调用动态”指令都具有唯一的链接状态。

方法返回指令（按返回类型区分）为*ireturn*（用于返回类型为“布尔”，“byte”，“ char”，“short”或“ int”的值），*lreturn*，*freturn*，*dreturn*和*areturn*。 另外，*return*指令用于从声明为void的方法，实例初始化方法以及类或接口初始化方法返回。

### 抛出异常

使用*athrow*指令以编程方式引发异常。 如果各种Java虚拟机指令检测到异常情况，也可以引发异常。

### 同步

Java虚拟机通过单个同步结构（*monitor*）支持方法和方法中指令序列的同步。

作为方法调用和返回的一部分，隐式执行方法级同步。 “同步”方法在运行时常量池的“method_info”结构中有所区别，则使用`ACC_SYNCHRONIZED`标志，该标志由方法调用指令进行检查。当调用设置了“ACC_SYNCHRONIZED”的方法时，执行线程将进入监视器，调用该方法本身，然后退出监视器，无论方法调用是正常完成还是突然完成。在执行线程拥有监视器的时间内，没有其他线程可以进入它。如果在调用`synchronized`方法的过程中引发了异常，并且`synchronized`方法未处理该异常，则该方法的监视器将自动退出，然后再将异常从`synchronized`方法中抛出。

指令序列的同步通常用于编码Java编程语言的“同步”块。 Java虚拟机提供了*monitorenter*和*monitorexit*指令来支持这种语言构造。 正确实现“同步”块需要与面向Java虚拟机的编译器进行协作。

*“结构化锁定”是在方法调用期间，给定监视器上的每个出口与该监视器上的先前条目匹配时的情况。 由于不能保证提交给Java虚拟机的所有代码都将执行结构化锁定，因此允许但不要求强制执行以下两个保证结构化锁定的规则的Java虚拟机实现。 假设* T*为线程，*M*为监视器。 然后：

1. 无论方法调用是正常完成还是突然完成，在方法调用过程中*M*上*T*执行的监视器入口数必须等于方法调用过程中*M*上 *T*所执行的监视器出口数。
2. 自从方法调用以来，由于方法调用引起的*T*对*M*执行的监视器退出的数量不得超过由*T*对*M*执行的监视条目的数量。

注意，当调用“同步”方法时，由Java虚拟机自动执行的监视器进入和退出被视为在调用方法的调用期间发生。

## 类库

Java虚拟机必须为Java SE平台的类库的实现提供足够的支持。 如果没有Java虚拟机的配合，就无法实现这些库中的某些类。

可能需要Java虚拟机特殊支持的类包括那些支持以下内容的类：

- 反射，例如包java.lang.reflect中的类和类Class。
- 加载和创建类或接口。 最明显的例子是类“ ClassLoader”。
- 类或接口的链接和初始化。 上面引用的示例类也属于此类别。
- 安全性，例如包java.security中的类以及其他类，例如SecurityManager中的类。
- 多线程，例如类`Thread`。
- 弱引用，例如包java.lang.ref中的类。

上面的列表是说明性的，而不是全面的。 这些类或它们提供的功能的详尽列表超出了本规范的范围。 有关详细信息，请参见Java SE平台类库的规范。

## Public设计，Private 实现

该规范已设计出Java虚拟机的公众轮廓：“ class”文件格式和指令集。这些组件对于Java虚拟机的硬件，操作系统和实现独立性至关重要。实现者可能更喜欢将它们视为在每个实现Java SE平台的主机之间安全地传递程序片段的一种手段，而不是要严格遵循的蓝图。

重要的是要了解公共设计与私有实现之间的界线在哪里。 Java虚拟机实现必须能够读取“class”文件，并且必须在其中完全实现Java虚拟机代码的语义。一种实现方法是将本文档作为规范，并按字面实现该规范。但是实现者在本规范的约束内修改或优化实现也是完全可行和合乎需要的。只要可以读取“类”文件格式并保持其代码的语义，实现者就可以以任何方式实现这些语义。只要精心维护正确的外部接口，“内幕”即是实施者的业务。

有一些例外：调试器，事件探查器和即时代码生成器每个都可能需要访问Java虚拟机的元素，这些元素通常被认为是“底层”。在适当的情况下，Oracle与其他Java虚拟机实现者和工具供应商合作，开发Java虚拟机的通用接口，以供此类工具使用，并在整个行业中推广这些接口。

实现者可以使用这种灵活性来定制Java虚拟机实现，以实现高性能，低内存使用或可移植性。在给定的实施方案中，什么才有意义取决于该实施方案的目标。实施选项的范围包括：

- 在加载时或执行期间将Java虚拟机代码转换为另一个虚拟机的指令集。
- 在加载时或执行期间将Java虚拟机代码转换为主机CPU的本机指令集（有时称为“即时”或“ JIT”代码生成）。

精确定义的虚拟机和目标文件格式的存在不必显着限制实现者的创造力。 Java虚拟机旨在支持许多不同的实现，在保留实现之间的兼容性的同时，提供了新的有趣的解决方案。